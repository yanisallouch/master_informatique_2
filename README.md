# Spécialité [Génie Logiciel](https://formations.umontpellier.fr/fr/formations/master-XB/master-informatique-ME154/genie-logiciel-PR476/m2-genie-logiciel-KMAH9BWB.html)

[https://informatique-fds.edu.umontpellier.fr/etudiants/offre-de-formation-lmd5/parcours-gl-genie-logiciel/](https://informatique-fds.edu.umontpellier.fr/etudiants/offre-de-formation-lmd5/parcours-gl-genie-logiciel/)

Description récupérée du LMD4, lorsque le parcours se nommait AIGLE.

*	Conception et développement d’architectures logicielles
	-	architectures orientées services
	-	architectures web
	-	urbanisation (architectures des systèmes d’informations)

*	Maîtrise de la conception et du développement par objets
*	Maîtrise des technologies web
*	Maîtrise de l’informatique embarquée (pour mobiles...)

#	Template de présentation d'un module

##	[Code - Intitulé](./README.md)
###	[Prénom NOM](https://www.example.com/) et [Prénom NOM](https://www.anotherexample.com) etc.

- les gros titres
- du cours avec 
- des redirections
-  si possibles

###	Bibliographie :

- si présent ajouté une bibliographie

<hr>

#	Présentation des modules

##	[HAI001I - Stage Académique](./HAI001I-StageAcademique)
###	[Souhila KACI](http://www.lirmm.fr/~kaci/)

Présentation du stage académique, informations particulières et des offres de stages disponibles.

##	[HAI002I - Stage Industrielle](./HAI002I-StageIndustrielle)
###	[Pierre POMPIDOR](http://www.lirmm.fr/~pompidor/)

Présentation du stage industrielle, informations particulières et des offres de stages disponibles.

##	[HAI908I - Conférence Logiciel](./HAI908I-ConferenceLogiciel)
###	[Abdelhak-Djamel SERIAI](http://www.lirmm.fr/~seriai/)

Dix séminaires soutenus pas des industrielles et scientifique autour du génie logicile, de l'intelligence artificielle, des méthodes formelles, etc.

1. L'industrialisation, par Jules Coulon (Sopra Steria, France)
2. L'outil KeY, par Simon Robillard (Lirmm, France)
3. L'intérêt de la recherche pour l'industrie, par Julien Morgan De Rivery et Benoît Verhaeghe (Berger-Levrault, France)
4. Numérique responsable : ecoCode, par Olivier Le Goaër (Université de Pau, France)
5. Méthode Formelle, Développement logiciel et Système sûr critique, par Etienne Prun (CLEARSY, France)
6. L'importance du CI/CD dans un projet de développement : R2DevOps, par Thomas Boni (Go2Scale, France)
7. Comment sont programmés les robots ?, par Robin Passama (CNRS/Lirmm, France)
8. Software Product Line Engineering: From Research Ideas to industrial Tools (Moobios Forge), par Tewfik Ziadi (Université Paris Sorbonne/LIP6 & RedFabriQ, France)
9. Ingénierie Logicielle Avancée grâce à Pharo, par Stéphane Ducasse (INRIA, France)
10. Software Engineering for the service of Services, par Naouel Moha (ETSM, Montréal)

##	[HAI912I - Developpement Mobile Avancée, IoT Et Embarqué](./HAI912I-DevMobAvan.IoT.EtEmbarq)
##	[Abderrahmane SERIAI](https://fr.linkedin.com/in/abderrahmane-seriai-phd-15063459) et [Yassine HADDAB](https://www.lirmm.fr/users/utilisateurs-lirmm/yassine-haddab) et [Alban MANCHERON](https://www.lirmm.fr/users/utilisateurs-lirmm/alban-mancheron)

1. Introduction à Flutter, par Abderrahmane SERIAI (Berger-Levrault, France)
2. Introduction a l'IoT par Yassine Haddab (Université de Montpellier, France)
3. Réseaux maillés a base de capteurs autonomes, par Alban Mancheron (Lirmm, France)

##	[HAI913I - Evolution et Restructuration du Logiciel](./HAI913I-EvolutionRestructurationLog)
###	[Abdelhak-Djamel SERIAI](http://www.lirmm.fr/~seriai/) et [Bachar RIMA (ext.)](https://fr.linkedin.com/in/bachar-rima-4b618311b) et [Pascal ZARAGOZA (ext.)](https://fr.linkedin.com/in/pascal-zaragoza-406120a9)

> Objectifs de ce cours : Présenter les aspects essentiels de la maintenance (évolution) des logiciels, selon deux aspects, technique et organisationnels.

1. Concepts et principes généraux de l'évolution logicielle
2. Analyse statique et dynamique des logiciels
3. Rétro-ingénierie : extraction d'architecture d'un système OO (a l'aide de la JDT : ASTParser et un framework tiers : Spoon)
4. Visualisation des logiciels (Moose/Pharo)
5. Gestion de la variabilité et lignes de produits
6. Compréhension des logiciels
7. Restructuration et refactoring des logiciels (Migration Monolithique vers Micro-Service, Refactoring assisté par FCA/RCA, etc.)

##	[HAI914I - Gestion des données au delà de SQL (NoSQL)](./HAI914I-GestionDonneesNoSQL)
###	[Isabelle MOUGENOT](https://fr.linkedin.com/in/isabelle-mougenot-596a2548) et [Federico ULLIANA](http://www.lirmm.fr/~ulliana/)

Une première partie de ce module, soutenu par Isabelle Mougenot, permet d'explorer différentes familles de systèmes NoSQL :

- Graphe : Neo4J
- KG : triplestore (langages web sémantique)
- Outil de mapping objet/relationnel Hibernate
- Document : CouchDB
- Colonne : Hbase
- Principes généraux : limites du relationnel, scalabilité, distribution, principe CAP, paradigme Map-Reduce

Dans une seconde partie, soutenu par François Scharffe, Federico Ulliana ainsi que deux doctorant, permet d'explorer la façon dont est manipuler l'information dans un système de base de donnée dit Hexastore, en essayant d'en implémenter un from scratch en Java et de nous introduire au benchmarking (principalement de SGBD, mais aussi plus généralement).

##	[HAI916I - Intelligence Artificielle et Génie Logiciel](./HAI916I-IntelligenceArtificielleEtGL)
###	[Marianne HUCHARD](https://www.lirmm.fr/users/utilisateurs-lirmm/marianne-huchard)

- Introduction IA et GL : qu’est-ce que l’IA, l'apprentissage, grandes directions en IA symbolique et sous-symbolique. Pointeurs vers des outils d'IA. Exemples de situations en génie logiciel. Introduction à l'Analyse formelle de concepts
- Analyse formelle de concepts et analyse de la variabilité. Construction de Feature Models à partir de structures conceptuelles
- Programmation par contraintes pour la génération de tests (1ere partie)
- Apprentissage automatique par analyse du code
- Programmation par contraintes pour la génération de tests (2e partie)
- Fouille de données pour la localisation de fautes (1ere partie)
- Fouille de données pour la localisation de fautes (2e partie)
- Analyse de la contribution architecturale dans les projets OS. Données GitHub, calcul de métrique, analyse statistique des résultats, interprétation (choix des visualisations adaptées)
- Classification de tickets dans les Issue Tracking Systems : distinction bug / non bug. Données issues d'IST (Jira), techniques de NLP (TF-IDF), classification supervisée, réseaux de neurones, évaluation (signification des écarts statistiques avec l'état de l'art)
- Clustering, q-learning pour la restructuration et la modernisation
- Analyse relationnelle de concepts et analyse de la variabilité logicielle par séparation des préoccupations
- Utilisation des métaheuristiques en GL. Cas d'étude : utilisation des CSP pour inférer des contraintes OCL

##	[HAI919I - Ingénierie des modèles](./HAI919I-IngenierieModeles)
###	[Clémentine NEBUT](https://www.lirmm.fr/users/utilisateurs-lirmm/clementine-nebut) et [Marianne HUCHARD](https://www.lirmm.fr/users/utilisateurs-lirmm/marianne-huchard)

1. Introduction : modèles et métamodèles
2. Transformations de modèles
3. Le méta-modèle UML - 29/09 - 14H
4. OCL (10 et 17 novembre)
5. Syntaxe textuelle et XText
6. Syntaxes graphiques avec Sirius

###	Bibliographie :

* Combemale, Benoit, Robert France, Jean-Marc Jézéquel, Bernhard Rumpe, James Steel, and Didier Vojtisek. Engineering modeling languages: Turning domain knowledge into tools. CRC Press, 2016.
* Jézéquel, Jean-Marc, Benoit Combemale, and Didier Vojtisek. Ingénierie Dirigée par les Modèles: des concepts à la pratique... Ellipses, 2012. (Preprint version HAL)

##	[HAI931I - Systèmes Réflexifs et Models@runtime](./HAI931I-SystemesReflexifsModels@runtime)
###	[Christophe DONY](http://www.lirmm.fr/~dony/)

But : Utilisation et Construction de Langages Réflexifs autorisant la Méta-Programmation. (#meta-programming #dynamic adaptability #model@runtime)

1. Définitions : modèles, méta-modèles, réflexivité, méta-programmation,
2. Utilisation de systèmes réflexifs
	- contexte du developpement par objet.
	1. Méta-Programmation, Utilisation de méta-objets (Smalltalk, Clos, ... Ruby, Pharo, Python, ...), pour interroger ou manipuler :
		- tout ou partie des modèles (par exemple les classes, les hiérarchies de classes, les attributs, les méthodes),
		- tout ou partie de la machinerie d'exécution des programmes (par exemple le compilateur, la pile d'exécution).
	2. Réalisation de méta-modèles exécutables avec MOF/Eclipse (voir models@runtime) ...
3. Construction de systèmes réflexifs
	1. Intégration de méta-classes explicites dans un langage à objets, avec son bootsrap.
	2. construction d'un interpréteur méta-circulaire
	3. Construction d'un interpréteur méta-circulaire réflexif
4. Projets Etudiants - Exploration ouverte multi-langages et multi-thématique (ObjVLisp)

##	[HAI933I - Théorie des bases de données et de connaissances](./HAI933I-TheorieBDD)
###	[Marie-Laure MUGNIER (Univ. Montpellier)](http://www.lirmm.fr/~mugnier/) et [Jean-François BAGET (Inria)](http://www.lirmm.fr/~baget/)

Informations générales
Prérequis : module "représentation des connaissances" (M1, HMIN231, 2021) ou équivalent pour les étudiants extérieurs.

Ce cours nécessite des bases en :
- logique du premier ordre (en particulier : interprétation, modèle, conséquence logique),
- systèmes à base de règles (en particulier : règles datalog, homomorphisme, requête conjonctive, chaînage avant, chaînage arrière),
- complexité (en particulier : classes P et NP).

1. Introduction
2. Fragment existentiel conjonctif : faits et requêtes conjonctives
3. Bases de connaissances : où l'on ajoute des règles et des contraintes
4. OWA / CWA : négation classique et négation par défaut
5. Règles existentielles
6. Answer Set Programming (ASP)

##	[HAI934I - Vérification automatique de programmes](./HAI934I-VerificationAutoProgramme)
###	[David DELAHAYE](http://www.lirmm.fr/~delahaye/) et [Vincent IAMPIETRO](http://www.lirmm.fr/~viampietro/)

1. Introduction à la vérification automatique de programmes
2. Rappel : Preuves en logique du premier ordre (Système LK/LJ)
3. Déduction automatique en logique propositionnelle classique (Procédure DPLL, Procédure de Résolution, Méthode des tableaux)
4. Déduction automatique en logique du premier ordre classique (Algorithme d'unification de Robinson, **Les** Méthodes des tableaux, Résolution)
5. Déduction modulo théorie et variantes (Règles de ré-écriture, Superdéduction)
6. Satisfiability Modulo Theories (SMT, DPLL Abstrait et optimisations)
7. Égalité avec symboles non interprétés (Théorie de l'égalité, congruence et une Procédure de décision)
8. Arithmétique linéaire (Seulement la partie *Rationnelle*, Simplexe généralisé)